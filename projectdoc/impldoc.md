## Implementation Document
This document details the implementation of the `rsautils` project, which provides utilities for RSA key generation, encryption, decryption, signing, and verification.

### Table of Contents
1. [Project Structure](#project-structure)
2. [Key Algorithms](#key-algorithms)
3. [Security Considerations](#security-considerations)
4. [Future Work](#future-work)
5. [AI Disclosure](#ai-disclosure)
6. [Sources](#sources)

### Project Structure
The project is organized into the following folders and files:

`src/rsautils/`: Contains the source code of the project with all relevant modules.
- `keygen.py`: Implements prime number generation and RSA prime pair generation. Has some helper functions for small prime generation, import, and export.
- `rsa.py`: The core RSA implementation, including key formation (using `keygen.py`), encryption, decryption, signing, verification, import, and export.
  - `RSAKey`: Class representing an RSA key (public or private), implements solely the core RSA operation.
  - `RSAPrivateKey`: Class representing an RSA private key, inherits from `RSAKey`. Implements CRT optimizations for core RSA operations.
    As well as key pair generation, import, export (PKCS#8 unencrypted), decryption, and signing.
  - `RSAPublicKey`: Class representing an RSA public key, inherits from `RSAKey`. Implements public key specific
operations such as encryption, verification, import, and export (PKCS#1).
- `__main__.py`: Handles the command-line usage of the `rsautils` package, implementing a hybrid CLI/iCLI (interactive CLI) interface.
- `__init__.py`: Initializes the package and exposes some core functions for easier access.

`tests/`: Contains unit tests for the project.
- `test_<module>.py`: Each module has a corresponding test file that includes unit tests for its functions and classes.
  For more details, see the [Test Document](testdoc.md).
- `testdata/`: Contains test data files used in the unit tests.
  - `get_test_data.py`: Script to generate test data files, usually not run unless test data needs to be updated.

`projectdoc/`: Contains documentation related to the project, including this implementation document.
- `specdoc.md`: The specification document outlining the requirements and design of the project.
- `impldoc.md`: This implementation document.
- `testdoc.md`: The test document detailing the testing strategy and coverage.
- `userguide.md`: The user documentation providing instructions on how to use the project.
- `week<n>.md`: Weekly progress reports documenting the development process.
- `week_template.md`: Template for weekly reports.

In addition, there are configuration files and metadata files in the root directory:
- `README.md`: The main readme file provides an overview of the project; it will link to the user guide and provide a brief introduction.
- `pyproject.toml`: Configuration file for project metadata and dependencies, used by the core development tool Poetry.
- `LICENSE`: The Eclipse Public License - v 2.0 file, specifying how this project is licensed.
- `.coveragerc`: Configuration for coverage.py to measure code coverage.
- `.gitignore`: Specifies files and directories to be ignored by Git.
- `pylintrc`: Configuration for pylint to enforce coding standards; used here is the Google style, with some modifications.
- `conftest.py`: Setup file for pytest, providing special mark handling for tests.
- `poetry.lock`: Lock file generated by Poetry to ensure consistent dependency versions.

### Key Algorithms
Most of the complex algorithms in the project are implemented in `keygen.py` with a limited number of such algorithms on
the `rsa.py` side.

Space complexity is assumed to be: O(*log* n)

#### Key Generation
Key generation algorithms are mostly based on the DSS standard [1], with some modifications for efficiency and localization to Python.

1. Sieve of Eratosthenes: Used for generating a list of small primes used in primary-level testing of primes during a full check run.
Moderately optimized for speed and memory usage, implemented using a boolean list, solely for odd numbers and stopping at the square root of the limit.
   - **Time Complexity**: O(n *log* *log* n)   where n is the limit up to which primes are generated.
   - **Space Complexity**: O(n) (though in practice half of n due to only storing odd numbers).

2. Limited Trial Division (LTD): Used as the first step in primality testing to quickly eliminate non-prime candidates. Uses the Sieve of Eratosthenes to generate small primes.
Iterates through the small primes up to the square root of the candidate number or a fixed limit (whichever is smaller) to check for divisibility. Returns false if any small prime divides the candidate, true otherwise.
   - **Time Complexity**: O(sqrt(n)/*log* sqrt(n)) in worst case, where n is the candidate.

3. Miller-Rabin (M-R) Primality Test: Performs probabilistic primality testing to determine if a number is likely to be prime. Core algorithm of the project.
Does not implement any special optimizations, mostly due to the complexity of such optimizations and the fact that Python is not a low-level language.
   - **Time Complexity**: O(k *log*<sup>3</sup> n) where k is the number of rounds and n candidate number.

4. Full Primality Test: Combines LTD and M-R tests to provide a full and moderately optimized primality test.
Implements some automatic parametrization based on the size (such as selecting the number of M-R rounds based on estimated security bits).
Acts mostly as an orchestration function for the two main algorithms.

5. Prime Pair Generation: Generates prime pairs (p, q) with some important properties for RSA, such as ensuring that p and q are not too close to each other.
Apart from special conditions, it mostly acts as an orchestration function, though it still has a specific FIPS 186-5 [1] algorithm for prime generation.

#### RSA Operations
On the RSA side, we mostly implement algorithms from RFC 8017 [2], with some modifications for efficiency and localization to Python.

1. Core RSA Operation: Implements the core RSA operation (modular exponentiation) using Python's built-in `pow` function with three arguments for efficiency.
   - **Time Complexity (Public Key)**: O(*log*<sup>2</sup> n)
   - **Time Complexity (Private Key)**: O(*log*<sup>3</sup> n)

2. CRT-Optimized Core RSA Operation: Implements the core RSA operation using the Chinese Remainder Theorem (CRT) for efficiency when using private keys with provided p and q.
   - **Time Complexity**: O(*log*<sup>3</sup> n) though in practice due to smaller calcs may be as much as 4x faster.

### Security Considerations
Some security considerations have been noted during the implementation of this project:
1. **Key Size**: The project restricts key sizes during generation to at least 2048 bits, which is considered secure for most applications today. The default key size is set to 3072 bits, which is the current recommendation by NIST [1].
2. **Padding Schemes**: The project implements actual RSA padding schemes for encryption (OAEP) and signing (PKCS#1 v1.5) to ensure security against various attacks.
3. **Side-Channel Resistance**: All private key operations implement constant-time algorithms to mitigate timing attacks and avoid raising specific exceptions that could leak information.
4. **Randomness**: The project uses Python's `secrets` module for generating cryptographic random numbers, ensuring high-quality randomness suitable for cryptographic applications.
5. **Safe Defaults & Explicit Warnings**: The project uses safe defaults for all operations and provides explicit warnings for insecure practices, such as the usage of academic RSA.
6. **Testing**: Comprehensive unit tests are provided to ensure the correctness and security of the implementation. Including tests for edge cases, invalid inputs, and correctness of failures.
7. **Standards Compliance**: The implementation adheres to established standards such as FIPS 186-5 [1] and RFC 8017 [2] to our best ability, ensuring interoperability and security.

### Future Work
Potential areas for future improvement and expansion of the project include:
1. **Backward Compatibility**: Implement support for older standards and formats, such as PKCS#1 v1.5 encryption and decryption. As well as older key formats like the PKCS#1 private key format.
2. **More Modern Signing**: Implement support for more modern signing schemes, such as PSS (Probabilistic Signature Scheme).
3. **Secure Key Storage**: Implement secure key storage mechanisms, such as PKCS#8 with encryption.
4. **More Advanced Prime Generation**: Implement more advanced prime generation techniques, such as primes with conditions or provable primes.

#### AI Disclosure
Gemini 2.5 Pro and Gemini 2.5 Flash with Enterprise Data Protections have been used for code and documentation checking.

#### Sources
1. Digital Signature Standard (DSS), FIPS 186-5, National Institute of Standards and Technology, Gaithersburg, MD, USA, Feb. 2023. [Online]. Available: https://doi.org/10.6028/NIST.FIPS.186-5
2. PKCS #1: RSA Cryptography Specifications Version 2.2, RFC 8017, IETF, Nov. 2016. [Online]. Available: https://doi.org/10.17487/RFC8017