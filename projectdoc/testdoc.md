## Testing Document
### Coverage
| Name                         |   Stmts |  Miss |  Branch | BrPart |    Cover |
|------------------------------|--------:|------:|--------:|-------:|---------:|
| src\rsautils\\_\_init\_\_.py |      10 |     0 |       0 |      0 |     100% |
| src\rsautils\keygen.py       |     132 |     0 |      70 |      0 |     100% |
| src\rsautils\rsa.py          |     274 |     0 |      62 |      0 |     100% |
| **TOTAL**                    | **416** | **0** | **132** |  **0** | **100%** |

### What was tested?
We tested every function in `keygen.py` for correctness and reliability over small and representative
inputs, using constant inputs where possible based on known-good generation results.

In contrast, a lot of the tests for `rsa.py` approach testing in a much more integration-testing approach
checking for end-to-end or interoperability testing rather than providing unit tests for each of the smaller
test functions.
This is due to the overall needs for such approach in encryption, decryption and such justifying our favor
towards such testing rather than unit tests and the current tests provide sufficient detail to test our implementation.

More specific fail-correctly unit tests have been made for `rsa.py` to expand branch coverage and ensure that all functions
fail in correct places due to the importance of said failures.

### Test Inputs
All test inputs are preset and depending on the test are either known-good lists of the smaller
primes or larger primes generated using `get_test_data.py` using a known good implementation of the
python `cryptography` library for that as well as exporting to template PKCS1 public key files
and PKCS8 private key files. Finally, some known large primes from the *Great Internet Mersenne Prime Search* Project
as well as a set of some NIST MODP groups as per RFC-3526.

### Sample Testing Details
1. `keygen.py` testing
   1. The Sieve of Eratosthenes has been comparatively tested against a known-good list of small primes from t5k.org
      Generating primes up to specified large numbers and comparing against the list. A rough check is also conducted via
      length comparison vs. expected number of primes for even larger amounts of primes.
   2. The Miller-Rabin algorithm, as well as it's enhanced version (with pre-run limited trial division) are tested with
      a variety of cases with known results
      1. Known Primes: We assert True against a variety of preset known primes, including small and reasonably
         large ones from the sources described beforehand.
      2. Composite: We assert False against a set of specifically chosen difficult numbers as well as composites created
         by multiplying the large primes used in part 1.
   3. The correctness of the generation process is also tested, mostly relying on the size of the expected key and testing
      if the key functions correctly.
2. `rsa.py` testing
   1. Most of the testing of the RSA protocols is focused on end-to-end as well as integration testing using both our own,
      and `cryptograpy` as end-to-end and known-good implementations respectively.
      1. This includes key-movement testing such as a key exported by our library may be imported by `cryptography`
         and vice versa.
      2. Furthermore, integration testing is ran on the raw bytes generated by the OAEP encryption so that our library
         is up to spec with the encryption itself. (A custom wrapper format is used in text-based, which would not be
         compatible).
      3. Finally, the signature/verification result in full is integration tested against the sample library.
   2. Some special fail-correctly cases have been implemented to assure that errors are risen correctly and anything
      that should fail, does to avoid security vulnerabilities and improve coverage. This includes malformed data
      testing (using specially crafted payloads) as well as key mismatch testing.

### Test Reproduction
All fo the tests can be reproduced using the information placed in the repository, outside the
issues present due to the probabilistic nature of the Miller-Rabin algorithm, but they should remain consistent
if not always cover all the branches in the function.

#### Test Run Command
```shell
pytest
```
with optional arguments to specify skipping of slow, running of extreme tests, coverage checks and coverage report format.
They follow the standard pytest conventions with the addition of these two shortcuts.
```shell
pytest --skip-slow 
```
Shortcut to skip slower (more than a second or two) tests
```shell
pytest --run-extreme
```
Shortcut to run extreme tests that are not practical and may take an unknown amount of time to run.