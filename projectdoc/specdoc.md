## Specification Document
**Project: rsautils** \
**Programming Language: Python** \
*Peer Langs: None I would proclaim sufficient knowledge to review an advanced project* \
**Language: English** \
**Programme: BSc**
### Algorithms:
Sieve of Eratosthenes \
Miller-Rabin Primality Test \
"Textbook" (AKA Unpadded) RSA \
*Further Algorithms that may be included given sufficient development time (in order of priority):* \
All features relying on those shall be in italics \
*Non-Academic RSA (Source 1)* \
*RSA Key Password Protection (Source 2)* \
*"Hardened" Prime Generation (Source 3)* \
*Provable Prime Generation (Source 3)*
### Problem:
Provision of data security in the currently very digital world. We will provide asymmetric encryption using RSA as well as RSA Key generation.
### Inputs and Handling:
**Key Generation:**
- Key Size (2048/3072/4096 bits)
- Public exponent (Optional: Suggest Fermat Prime use) Default: 65537

Used in the generation of they key to determine the public exponent as well as the size, both impacting the security and speed. \
**Encryption:**
 - Message
 - RSA Key
 - *Encryption method Academic or Secure*

Encrypt the message using the RSA Key provided according to the chosen encryption method. \
**Decryption:**
 - Ciphertext
 - Respective RSA Key
 - *Encryption method*

Decrypt the ciphertext using the RSA Key according to the decryption method. \
**Sign**
 - Message
 - RSA Key
 - *Signature Method*

Sign the message using the RSA Key and method. \
**Verify**
 - Message
 - Signature
 - Respective RSA Key
 - *Signature Method*

Verify that the Signature has been generated with the respective RSA Key and signs the message according to Signature Method. \
### Time and Space Complexity (Expected):
The following are for baseline implementations of the core (non-optional) algorithms:

| Algorithm                            | Time Complexity           | Space Complexity | Arguments                                        |
|--------------------------------------|---------------------------|------------------|--------------------------------------------------|
| Sieve of Eratosthenes                | O(n *log* *log* n)        | O(n)             | n - Highest Number Checked for Prime             |
| Miller-Rabin Primality Test          | O(k *log*<sup>3</sup> n)  | O(*log* n)       | n - Number Being Tested, k- Number of Tests      |
| RSA Key Generation                   | O(k(*log*<sup>4</sup> n)) | O(*log* n)       | n - Desired Prime Magnitude, k- Number of Tests  |
| Textbook RSA Encryption/Verification | O(*log*<sup>2</sup> n)    | O(*log* n)       | n - RSA Modulus                                  |
| Textbook RSA Decryption/Signing      | O(*log*<sup>3</sup> n)    | O(*log* n)       | n - RSA Modulus                                  |

Optional implementations are not represented as no specific algorithm has been selected for all of them.
#### Sources:
1. PKCS #1: RSA Cryptography Specifications Version 2.2, RFC 8017, IETF, Nov. 2016. [Online]. Available: https://doi.org/10.17487/RFC8017
2. Advanced Encryption Standard (AES), FIPS 197 (Update 1), National Institute of Standards and Technology, Gaithersburg, MD, USA, Feb. 2023. [Online]. Available: https://doi.org/10.6028/NIST.FIPS.197-upd1
3. Digital Signature Standard (DSS), FIPS 186-5, National Institute of Standards and Technology, Gaithersburg, MD, USA, Feb. 2023. [Online]. Available: https://doi.org/10.6028/NIST.FIPS.186-5
### Description:
The core of the project will be the generation of random primes as it is the most complex algorithm related to the generation of RSA keys.
This will be implemented using the probable prime finding method pruning via set list of known primes generated by Sieve of Eratosthenes and then applying the Miller-Rabin primality test.
While some further algorithms are needed for "Textbook" RSA the implementation is quite simple but important for this project.
The project is planned to be in a form closer to a library/package rather than a program, but a simple Command Line Interface will be provided sourcing input from arguments first and an interactive process second
will be provided via the `__main__.py` file. Providing both fully automated as well as more human-readable interface. This allows for easy testing of the functionalities.
*Finally, if time allows I will attempt to implement more advanced RSA algorithms, including padding for more realistic encryption.*
*As a further possible goal, but quite unlikely is the implementation of AES-based password protection for RSA keys.*

I will consider placeholder optional features with functions imported from another library, for a more complete experience regardless of progress.
